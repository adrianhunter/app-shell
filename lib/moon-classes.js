// Generated by LiveScript 1.5.0
(function(){
  var swarm, signalhub, ref$, toHex, createAccount, EventEmitter, memdb, hsodium, split, sodium, hyperlog, tou8, level, onend, through, Worker, Log, log, hypercore, MYHUBS, peers, _subStreams, subscriptionIndex, state, basicWorkerHandle, worker, Sub, Pub, createSwarm, out$ = typeof exports != 'undefined' && exports || this;
  swarm = require('webrtc-swarm');
  signalhub = require('signalhub');
  ref$ = require('./hyper-utils'), toHex = ref$.toHex, createAccount = ref$.createAccount;
  EventEmitter = require('events').EventEmitter;
  memdb = require('memdb');
  hsodium = require('hyperlog-sodium');
  split = require('split2');
  sodium = require('chloride/browser');
  hyperlog = require('hyperlog');
  tou8 = require('buffer-to-uint8array');
  level = require('level-browserify');
  onend = require('end-of-stream');
  through = require('through2');
  Worker = require('webworkify');
  Log = require('./log-service');
  log = new Log;
  hypercore = require('hypercore');
  MYHUBS = ['http://localhost:1337'];
  peers = {};
  _subStreams = {};
  subscriptionIndex = 0;
  state = {
    recordId: null
  };
  basicWorkerHandle = function(ev){
    log.info('event from <- worker');
    switch (ev.data.type) {
    case 'publication.info':
      log.info('New PUBLICATION INFO!!!!!', ev.data);
      state.recordId = ev.data.id;
      return createSwarm(ev.data.id);
    case 'peer.data':
      log.info('RECV PEER', ev.data.buffer.length);
      return peers[ev.data.peerId].write(Buffer(ev.data.buffer));
    case 'subscription.data':
      log.info('PLAY DATA', ev.data.buffer.length);
      return _subStreams[ev.data.index].write(Buffer(ev.data.buffer));
    }
  };
  worker = Worker(require('./worker.js'));
  worker.addEventListener('message', basicWorkerHandle);
  out$.Sub = Sub = (function(superclass){
    var prototype = extend$((import$(Sub, superclass).displayName = 'Sub', Sub), superclass).prototype, constructor = Sub;
    function Sub(arg$){
      var topic, hubs, db, skip, limit, secret, fookey, index;
      topic = arg$.topic, hubs = arg$.hubs, db = arg$.db, skip = arg$.skip, limit = arg$.limit, secret = arg$.secret;
      log.info('creating new subscription with: ', arguments);
      this.key = createAccount();
      fookey = tou8(topic);
      createSwarm(topic, hubs);
      this.topic = topic;
      index = subscriptionIndex++;
      _subStreams[index] = through();
      worker.postMessage({
        type: 'subscription.start',
        topic: topic,
        skip: skip,
        secret: secret,
        limit: limit,
        index: index
      });
    }
    return Sub;
  }(EventEmitter));
  out$.Pub = Pub = (function(superclass){
    var prototype = extend$((import$(Pub, superclass).displayName = 'Pub', Pub), superclass).prototype, constructor = Pub;
    function Pub(arg$){
      var topic, hubs, db, newKey, this$ = this;
      topic = arg$.topic, hubs = arg$.hubs, db = arg$.db;
      log.info('creating new publication with: ', arguments);
      this.topic = topic;
      this.key = createAccount();
      newKey = {
        publicKey: toHex(this.key.publicKey),
        privateKey: toHex(this.key.secretKey)
      };
      log.info(newKey);
      createSwarm(topic, hubs, function(peerId){
        log.info('swarm created, peerId: ', peerId);
        return this$.peerId = peerId;
      });
      worker.postMessage({
        type: 'publication.start'
      });
    }
    Pub.prototype.stop = function(){};
    Pub.prototype.send = function(message){
      return worker.postMessage({
        type: 'publication.message',
        message: message,
        peerId: this.peerId
      });
    };
    return Pub;
  }(EventEmitter));
  createSwarm = function(topic, hubs, cb){
    var swar;
    hubs = hubs || MYHUBS;
    log.info('creating swarm: ', topic, hubs);
    swar = swarm(signalhub('spellcast.' + topic, hubs));
    swar.on('peer', function(peer, peerId){
      peers[peerId] = peer;
      worker.postMessage({
        type: 'peer.start',
        peerId: peerId
      });
      peer.on('data', function(buf){
        log.info('getting peer data from swarm: ', buf);
        worker.postMessage({
          type: 'peer.data',
          peerId: peerId,
          buffer: buf
        });
        return;
      });
      onend(peer, function(){
        worker.postMessage({
          type: 'peer.end',
          peerId: peerId
        });
      });
      if (cb) {
        cb(peerId);
      }
    });
  };
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
