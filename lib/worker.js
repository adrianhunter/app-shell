// Generated by LiveScript 1.5.0
(function(){
  var hypercore, level, core, Queue, hubs, swarm, window, Log, log, tobuf;
  hypercore = require('hypercore');
  level = require('level-browserify');
  core = hypercore(level('hypercore'));
  Queue = require('ordered-queue');
  hubs = ['http://localhost:1337'];
  swarm = require('webrtc-swarm');
  window = self;
  Log = require('./log-service');
  log = new Log;
  tobuf = function(blob, cb){
    var r;
    r = new FileReader;
    r.addEventListener('loadend', function(){
      cb(Buffer(new Uint8Array(r.result)));
    });
    r.readAsArrayBuffer(blob);
  };
  module.exports = function(self){
    var mode, feed, writeQueue, writeSeq, swarms;
    mode = null;
    feed = undefined;
    writeQueue = undefined;
    writeSeq = 0;
    swarms = {};
    return self.addEventListener('message', function(ev){
      var stream, mode, id, seq;
      log.info('event -> into worker', ev.data);
      switch (ev.data.type) {
      case 'publication.start':
        log('publication-start!!!');
        stream = core.createWriteStream();
        writeQueue = new Queue(function(buf, next){
          log.info('write quie');
          stream.write(buf);
          next();
        }, {
          concurrency: 10
        });
        mode = 'record';
        id = stream.key.toString('hex');
        feed = stream.feed;
        self.postMessage({
          type: 'publication.info',
          id: id
        });
        break;
      case 'peer.start' && feed:
        log.info('peer start!', ev.data.peerId);
        id = ev.data.peerId;
        swarms[id] = feed.replicate({
          live: true,
          encrypted: false
        });
        swarms[id].on('data', function(buf){
          log.info('peer start data!!!', buf);
          self.postMessage({
            type: 'peer.data',
            peerId: id,
            buffer: buf
          });
        });
        break;
      case 'peer.data':
        swarms[ev.data.peerId].write(Buffer(ev.data.buffer));
        break;
      case 'peer.end':
        console.warn('PEER END', ev.data.peerId);
        swarms[ev.data.peerId].end();
        break;
      case 'record.data' && mode === 'record':
        seq = writeSeq++;
        tobuf(ev.data.blob, function(buf){
          writeQueue.push(seq, buf);
        });
        break;
      case 'subscription.start':
        log('subscription-start!!!', ev);
        stream = core.createReadStream(ev.data.secret, {
          live: true
        });
        feed = stream.feed;
        stream.on('data', function(buf){
          log.info('XXXX GETTING STREAM DATA!!!');
          self.postMessage({
            type: 'subscription.data',
            index: ev.data.index,
            buffer: buf
          });
        });
        break;
      case 'publication.message':
        log.info('xxxxxxxxxxxx');
        log.info(writeQueue);
        log.info(ev);
        seq = writeSeq++;
        writeQueue.push(seq, Buffer(ev.data.message));
      }
    });
  };
}).call(this);
