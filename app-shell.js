// Generated by LiveScript 1.5.0
(function(){
  var level, yo, uuid, _, Router, singlePage, sodium, swarm, signalhub, memdb, hsodium, split, through, hyperlog, store, LOGS_DB, STATE_DB, getDB, readDB, hubs, COLLECTION_BASE, App, SERVICES, str2ab, Subscription, Publication, getDatabase, Helpers, createElement;
  level = require('level-browserify');
  yo = require('yo-yo');
  uuid = require('uuid');
  _ = require('underscore');
  Router = require('routes');
  singlePage = require('single-page');
  sodium = require('chloride/browser');
  swarm = require('webrtc-swarm');
  signalhub = require('signalhub');
  memdb = require('memdb');
  hsodium = require('hyperlog-sodium');
  split = require('split2');
  through = require('through2');
  hyperlog = require('hyperlog');
  store = require('store');
  LOGS_DB = level('./logsDB');
  STATE_DB = level('./stateDB', {
    valueEncoding: 'json'
  });
  getDB = function(db, cb){
    var data;
    data = [];
    db.createReadStream().on('data', function(r){
      return data.push(r);
    }).on('end', function(){
      if (cb) {
        return cb(data);
      }
    });
  };
  readDB = function(db, key, cb){
    var data;
    data = [];
    db.createReadStream().on('data', function(r){
      if (r.key.indexOf(key > -1)) {
        return data.push(r.value);
      }
    }).on('end', function(){
      if (cb) {
        return cb(data);
      }
    });
  };
  hubs = ['http://localhost:8080'];
  window.sodium = sodium;
  COLLECTION_BASE = (function(){
    COLLECTION_BASE.displayName = 'COLLECTION_BASE';
    var _key, prototype = COLLECTION_BASE.prototype, constructor = COLLECTION_BASE;
    COLLECTION_BASE.prototype.db = null;
    _key = null;
    COLLECTION_BASE.prototype.getEntrys = function(cb){
      return readDB(this.db, _key, cb);
    };
    function COLLECTION_BASE(name, options){
      var _key;
      options == null && (options = {});
      _key = "_collection_" + name + "_";
      this.db = options.db || STATE_DB;
    }
    COLLECTION_BASE.prototype.find = function(query, cb){
      return this.getEntrys(function(entrys){
        return console.log(entrys);
      });
    };
    COLLECTION_BASE.prototype.get = function(_id, cb){
      var this$ = this;
      return this.db.get(_key + _id, function(e, r){
        return cb((typeof this$.transform == 'function' ? this$.transform(r) : void 8) || r, e);
      });
    };
    COLLECTION_BASE.prototype.create = function(obj, cb){
      var data, _id;
      data = obj;
      console.log('creating!', data);
      _id = uuid();
      return this.db.put(_key + _id, data, function(e){
        if (cb) {
          return cb(_id, e);
        }
      });
    };
    return COLLECTION_BASE;
  }());
  App = (function(){
    App.displayName = 'App';
    var yoInstances, _publications, _subscriptions, _currentLayout, log, sw, keys, keypair, prototype = App.prototype, constructor = App;
    yoInstances = new Map;
    _publications = new Map;
    _subscriptions = new Map;
    _currentLayout = null;
    App._TEMPLATES = null;
    App._COLLECTIONS = null;
    App._ROUTES = null;
    log = null;
    sw = null;
    keys = null;
    App.userId = null;
    keypair = store.get('keys');
    function App(arg$){
      var TEMPLATES, COLLECTIONS, ROUTES, this$ = this;
      TEMPLATES = arg$.TEMPLATES, COLLECTIONS = arg$.COLLECTIONS, ROUTES = arg$.ROUTES;
      if (!TEMPLATES || !COLLECTIONS || !ROUTES) {
        throw new Error('LKJ!H@#!)*&)(!*@');
      }
      this._TEMPLATES = TEMPLATES;
      this._COLLECTIONS = COLLECTIONS;
      this._ROUTES = ROUTES;
      SERVICES.initCollections(this._COLLECTIONS);
      this.router = Router();
      this.showPage = singlePage(function(href){}, {});
      _.each(this._ROUTES, function(route){
        console.log('asd');
        console.log(route, 'adding route!');
        return this$.router.addRoute(route.path, route.action.bind(this$));
      });
      console.log(location.path);
      console.log(this._TEMPLATES, 'init _ template');
      this.go(location.pathname);
    }
    App.prototype.log = function(log, cb){
      if (cb) {
        LOGS_DB.put('log', log, r(cb(r)));
      }
    };
    App.prototype.getLogs = function(cb){
      getDB(LOGS_DB, cb);
    };
    App.prototype.getState = function(cb){
      getDB(STATE_DB, cb);
    };
    App.prototype.streamLogs = function(){
      return DB.createReadStream();
    };
    App.prototype.streamState = function(){
      return DB.createReadStream();
    };
    App.prototype.updateUi = function(){
      return this.getState(function(state){
        return yoInstances.forEach(function(instance){});
      });
    };
    App.prototype.updateState = function(operations, cb){
      return STATE_DB.batch(operations, function(e){
        if (cb) {
          return cb(e);
        }
      });
    };
    App.prototype.addView = function(targetEl, view){
      var this$ = this;
      return this.getState(function(state){
        var instance;
        instance = view.template({
          state: state
        });
        targetEl.appendChild(instance);
        return yoInstances.set(view.name, instance);
      });
    };
    App.prototype.removeView = function(view){};
    App.prototype.updateView = function(view){
      return this.getState(function(state){
        return yo.update(yoInstances.get(view.name, view.template(state)));
      });
    };
    App.prototype.go = function(routeName){
      var route;
      route = this.router.match(routeName);
      if (route) {
        return route.fn.apply(null, [null, null, route.params, route.splats]);
      }
    };
    App.prototype.render = function(arg$){
      var template, layout, targetId;
      template = arg$.template, layout = arg$.layout, targetId = arg$.targetId;
      console.log(layout);
      if (layout) {
        document.body.innerHTML = layout.template();
      }
      return document.getElementById(targetId).appendChild(template.template());
    };
    App.prototype.box = function(){
      var keypair, keys;
      keypair = sodium.crypto_box_keypair();
      keys = {
        publicKey: keypair.publicKey.toString('hex'),
        secretKey: keypair.secretKey.toString('hex')
      };
      store.set('boxkeys', keys);
    };
    App.prototype.createAccount = function(){
      var keypair, _keys;
      keypair = sodium.crypto_sign_keypair();
      return _keys = {
        publicKey: keypair.publicKey.toString('hex'),
        secretKey: keypair.secretKey.toString('hex')
      };
    };
    App.prototype.getLog = function(){
      return log;
    };
    App.prototype.sign = function(message){
      var secretKey, msg, sig;
      secretKey = Buffer(_keys.secretKey, 'hex');
      msg = new Buffer(message);
      sig = sodium.crypto_sign_detached(msg, secretKey);
      return sig.toString('hex');
    };
    App.prototype.verify = function(sig, pub, message){
      var publicKey, msg, ok;
      publicKey = Buffer(pub, 'hex');
      sig = Buffer(sig, 'hex');
      msg = new Buffer(message);
      ok = sodium.crypto_sign_verify_detached(sig, msg, publicKey);
      console.log(ok);
    };
    App.prototype.publish = function(opts){
      return _publications.set(opts.name, new Publication(opts));
    };
    App.prototype.subscribe = function(opts){
      return _subscriptions.set(opts.name, new Subscription(opts));
    };
    App.prototype.getDatabase = function(cb){
      var data;
      data = [];
      log.db.createReadStream().on('data', function(entry){
        console.log(entry);
        data.push(entry);
      }).on('end', function(){
        cb(data);
      });
    };
    return App;
  }());
  SERVICES = {
    initCollections: function(collections){
      return Object.keys(collections).forEach(function(key){
        var foo;
        foo = new COLLECTION_BASE;
        return window[key] = _.extend(collections[key], foo);
      });
    },
    initRoutes: function(appInstance, routes){}
  };
  module.exports = function(){
    return {
      App: App,
      SERVICES: SERVICES
    };
  };
  str2ab = function(str){
    var buf, bufView, i, strLen;
    buf = new ArrayBuffer(32);
    bufView = new Uint8Array(buf);
    i = 0;
    strLen = str.length;
    while (i < strLen) {
      bufView[i] = str.charCodeAt(i);
      i++;
    }
    return bufView;
  };
  Subscription = function(opts){
    var self, swormOpts;
    console.log({
      foo: opts.publicKey
    });
    self = this;
    this.log = hyperlog(memdb(), hsodium(sodium, {
      publicKey: opts.publicKey
    }));
    swormOpts = {};
    if (typeof window === 'undefined') {
      swormOpts.wrtc = require('wrtc');
    }
    this.sw = swarm(signalhub(opts.topic || opts.publicKey, hubs), swormOpts);
    this.sw.on('peer', function(peer, id){
      console.log('piping log!!');
      peer.pipe(self.log.replicate()).pipe(peer);
    });
    this.log.createReadStream({
      live: true
    }).on('data', function(e, r){
      console.log('getting read stream data');
      console.log(e, r);
    });
    this.getDb = function(cb){
      return getDatabase(self.log, cb);
    };
  };
  Publication = function(opts){
    var self, swormOpts;
    self = this;
    this.keypair = sodium.crypto_sign_keypair();
    this.keys = {
      publicKey: this.keypair.publicKey.toString('hex'),
      secretKey: this.keypair.secretKey.toString('hex')
    };
    console.log('PUBKEY: ', this.keys.publicKey);
    this.log = hyperlog(memdb(), hsodium(sodium, this.keypair));
    swormOpts = {};
    if (typeof window === 'undefined') {
      swormOpts.wrtc = require('wrtc');
    }
    this.sw = swarm(signalhub(opts.topic || this.keys.publicKey, hubs), swormOpts);
    this.send = function(message){
      self.log.append(message, {
        valueEncoding: 'utf8'
      }, function(err, node){
        if (err) {
          console.error(err);
        } else {
          console.log(node.key);
        }
      });
    };
    this.getDb = function(cb){
      return getDatabase(self.log, cb);
    };
    this.sw.on('peer', function(peer, id){
      console.log('piping log!!');
      peer.pipe(self.log.replicate()).pipe(peer);
    });
  };
  getDatabase = function(log, cb){
    var data;
    data = [];
    log.db.createReadStream().on('data', function(entry){
      console.log(entry);
      data.push(entry);
    }).on('end', function(){
      cb(data);
    });
  };
  Helpers = {
    DOM: [
      {
        setLayout: function(htmlString){
          return document.body.innerHTML(htmlString);
        }
      }, createElement = function(id){
        return document.body.appendChild(document.createElement("div").id = id);
      }
    ]
  };
}).call(this);
